# Ruby on Rails Juniors

## Введение в профессиональную разработку на Ruby on Rails

#### Начало работы

Последовательность команд для установки Ruby on Rails на Ubuntu:

```bash
sudo apt-get update -y
sudo apt-get install build-essential bison openssl libreadline6 libreadline6-dev curl git-core zlib1g zlib1g-dev libssl-dev libyaml-dev libsqlite3-0 libsqlite3-dev sqlite3 libxml2-dev libxslt-dev autoconf libc6-dev nodejs -y
curl -L get.rvm.io | bash -s stable
source ~/.rvm/scripts/rvm
rvm install 2.1.1
rvm use 2.1.1 --default
gem install rails --no-rdoc --no-ri
```

После этого становится доступной команда создания нового rails-приложения `rails new {applicaion name}`. Затем необходимо перейти в каталог созданного приложения и запустить rails-сервер командой `rails s`. После этого приложение становится доступным в браузере на [localhost:3000](http://localhost:3000).

Пример создания приложения `first_app` и запуска его сервера:

```bash
rails new first_app
cd first_app
rails s
```

Чтобы запустить сервер на другом порте, необходимо указать номер порта с ключом `-p`:
```
rails s -p 5555
```
запустит сервер на порте 5555, и в браузере приложение нужно будет искать на [localhost:5555](http://localhost:5555).

#### Getting started: приступая к работе
В этом практическом задании рассмотрено большое количество очень разных вопросов, объединенных, тем не менее, плотным смысловым единством _(состоящим, пожалуй, в том, без всех этих вещей ни с одним rails-приложением нельзя сделать почти ничего)_:
- **Bundler** - пакетный менеджер Rails;
- язык описания представлений (views) **Slim**;
- **Twitter Bootstrap** для **Asset pipeline**;
- контроллер статических страниц;
- введение в роутинг;
- первое знакомство с хелперами.

В качестве бонуса освоим работу с хелпером `content_for`, который вовсе не так общезначим, но может иногда пригодиться.

Устанавливаем slim — в `Gemfile` добавляем
```ruby
gem 'slim-rails'
```
В каталоге приложения запускаем команду
```bash
bundle install
```
Впрочем, install — это наиболее востребованная операция Bundler'a, которая делается им по умолчанию, поэтому `bundle install`, как правило сокращается просто до
```
bundle
```
Это нужно делать всегда после обновления `Gemfile`, больше не будем на этом останавливаться.

Теперь мы можем создавать вьюхи на slim'e. Кроме того, теперь, когда мы выбрали язык описания представлений, можно установить [**Twitter Bootstrap**](https://github.com/seyhunak/twitter-bootstrap-rails).

Читаем документацию в readme по ссылке _(привыкаем к этому, это теперь на всю профессиональную жизнь в Rails)_, осмысливаем и делаем только то, что нам нужно:

Добавляем в `Gemfile`:
```ruby
gem 'therubyracer'
gem 'less-rails'
gem 'twitter-bootstrap-rails'
```
Затем запустим в каталоге приложения генераторы необходимых стилевых таблиц
```
rails generate bootstrap:install less
```
Теперь можно бегло глянуть `application.css` и `application.js`, чтобы примерно понять, как работает **Asset pipeline**, а позже обязательно внимательно прочитать [документацию](http://guides.rubyonrails.org/asset_pipeline.html).

Тем не менее, не отвлекаемся сильно и создаем главный layout приложения (здесь и далее: команда `rails` всегда выполняется в каталоге приложения):
```
rails g bootstrap:layout application fluid
```
Удаляем старый ужасный `application.html.erb` из `/app/views/layouts/`, и, чтобы увидеть значительные изменения, создаем контроллер статических страниц, воспользовавшись диалогом RubyMine или выполнив команду
```
rails g controller Page home index about info test
```
Выполнить команду, пожалуй, даже интереснее — ознакомление со списком созданных файлов в этом случае происходит более наглядно.

Теперь пора познакомиться с системой автоматической сборки кода **Rake** и запросить у нее список обслуживаемых приложением путей (здесь и далее: команда `rake` точно так же всегда запускается в каталоге приложения):
```
rake routes
```
Теперь на [localhost:3000](http://localhost:3000) нам открыты все пути, перечисленные в `rake routes`! _Если не открыты, запустите сервер и не забывайте его включать и выключать по необходимости — это тоже очень важный навык._

Однако в самом корне [localhost:3000](http://localhost:3000) пока еще стартовая страница по умолчанию.

В `routes.rb` (который находится в папке `/config` приложения) пишем
```ruby
root 'page#home'
```
или, для большего соответствия с полным синтаксисом `routes.rb`
```ruby
root to: 'page#home'
```
Работать будет и так, и так — делайте выбор из ваших синтаксических предпочтений. С помощью команды `root` можно направить корневой адрес приложения любому действию (action) любого контроллера, указав их в _(желательно одинарных)_ кавычках в формате `:controller#:action`.

Полностью команда настройки статического пути выглядит так:
```ruby
get '{:path}', to: ':controller#:action', as: {:alias}
```
Рассмотрим на примере:
```ruby
get 'page', to: 'page#index', as: :page
```
Все примерно понятно и знакомо, но зачем же alias? Снова запустим `rake routes` и найдем все элиасы в первой колонке таблицы, озаглавленном **Prefix**.
Теперь в `application.html.slim` (который, мы помним, в `/app/views/layouts`) найдем ссылки в шапке сайта и поправим их в соответствии со структурой нашего приложения:
```ruby
li = link_to 'Pages index', :page
```
Первый и, пожалуй, самый важный встреченный нами хелпер _**(ruby-функция rails, генерирующая html-код на основании переданных параметров)**_ `link_to` применяется, очевидно, для описания ссылок и первым параметром принимает текст или html-код отображения ссылки, вторым — адрес, на который будет указывать ссылка. Далее можно будет указать дополнительные параметры, как то `style:` или `class:`, но об этом позже. Адрес ссылки можно задать, помимо уже известного, еще двумя способами:
```ruby
li = link_to 'Pages index', page_path
```
и
```ruby
li = link_to 'Pages index', page_url
```
Встроенные методы rails `{:prefix}_path` и `{:prefix}_url` создадут соответственно относительный от корня сайта адрес страницы и абсолютный url, включающий адрес сайта. На локалхосте разницу, конечно, не заметить, но знать это надо. Вот мы и разобрались с префиксами роутов.

Продолжаем. В `routes.rb` пишем что-то вроде
```ruby
get 'any/other/page/anywhere/at/your/site', to: 'page#info', as: :info
```
в `application.html.slim`
```ruby
li = link_to 'Cool page', :info
```
Обновляем страничку, давим ссылку, читаем url в браузере и наслаждаемся полнотой своего понимания статического роутинга.

Теперь самое время заменить ужасную html-ную ссылку на главную страницу, которая, ко всем прочим недостаткам, из коробки `twitter bootstrap gem` еще и не работает (видимо, по каким-то серьезным идейным соображениям). Меняем
```
a.brand href="#"{:app_name}
```
на
```ruby
= link_to 'Practice', :root, class: %i[brand]
```
И запоминаем на всю жизнь, что тегов `a` во вьюхах рельсов **не бывает**. Для этого мы только что с таким трудом изучали соответствующий хелпер.

Еще об одном хелпере — `content_for`. В `application.html.slim` есть многообещающее
```ruby
title = content_for?(:title) ? yield(:title) : "Practice"
```
Как же задать этот title? _(использованный здесь тернарный оператор, конечно же, всем знаком)_ В любой взятой наугад вьюхе, например, `app/views/page/index.html.slim`, лучше всего в самой первой строчке, пишем:
```ruby
- content_for :title
  | Проникновенный и точный заголовок индексной страницы по умолчанию
```
И это, собственно, все. Сравниваем с заголовками вьюх, где `content_for :title` не определен и озаряемся пониманием.

Для закрепления поменяем последнюю ссылку в сайдбаре на
```ruby
li = content_for?(:sidebar) ? yield(:sidebar) : link_to("Link 3", "/path3")
```
Соответственно, во вьюхе, в которой мы хотим заменять эту ссылку, пишем, например:
```ruby
- content_for :sidebar
  - link_to 'Home Sweet Home', :root, style: 'color:green'
```
Вот, собственно, и весь `content_for` — второй хелпер, рассмотренный в этом курсе. Их еще много, и пора переходить к следующему занятию, где мы поближе познакомимся со странными двоеточими в начале некоторых слов, имеющими прямое отношение к важным различиям между символами и строками в ruby, и, возможно, даже с процентными литералами.

Можно пока остальные ссылки в лэйауте приложения допилить и все `content_for` снести. Ну, или, наоборот, добавить, если эффект понравился.

#### Getting continued: немного Ruby и FizzBuzz-тест (beginner & NIGHTMARE)

В ходе этой небольшой, но важной работы мы
- сформулируем самое общее представление о Ruby как о языке программирования;
- узнаем самые важные вещи об объектной модели Ruby;
- выделим самый важный класс объектов не только Ruby, а, возможно, всей Computer science;
- разберемся наконец с разницей между символами и строками в Ruby;
- сделаем простейшую реализацию принципа duck typing;
- немного затронем регулярные выражения и процентные литералы;
- **а также проверим свои навыки постановки и решения прикладных задач**.
